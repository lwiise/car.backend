<script>
(() => {
  /* ===================== CONFIG ===================== */
  const DEFAULT_SITE = "https://carbackendd.netlify.app";
  const FUNCTIONS_ORIGIN =
    (typeof window !== "undefined" && window.FUNCTIONS_ORIGIN)
      ? String(window.FUNCTIONS_ORIGIN).replace(/\/+$/, "")
      : DEFAULT_SITE;
  const NETLIFY_BASE = `${FUNCTIONS_ORIGIN}/.netlify/functions`;
  const FN_URL = `${NETLIFY_BASE}/carMatchCORS`;
  const RESULTS_URL  = "/results";
  const AUTO_NEXT_SKIP = new Set(["q6","q9"]);
  const DEBUG = true;

  /* ===================== BRANDING ===================== */
  function injectBranding() {
    if (!document.head || document.getElementById("brand-theme")) return;

    const link = document.createElement("link");
    link.id = "brand-fonts";
    link.rel = "stylesheet";
    link.href =
      "https://fonts.googleapis.com/css2?family=Syne:wght@500;600;700&family=Montserrat:wght@400;500;600&display=swap";
    document.head.appendChild(link);

    const style = document.createElement("style");
    style.id = "brand-theme";
    style.textContent = `
      :root{
        --brand-bg:#060a0e;
        --brand-bg-2:#030608;
        --brand-ink:rgba(255,255,255,.94);
        --brand-muted:rgba(255,255,255,.68);
        --brand-outline:rgba(255,255,255,.1);
        --brand-surface:rgba(142,165,182,.05);
        --brand-overlay-light:rgba(4,8,12,.3);
        --brand-overlay:rgba(4,8,12,.5);
        --brand-overlay-dark:rgba(4,8,12,.6);
        --brand-accent:142,165,182;
      }
      body{
        color:var(--brand-ink);
        font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      h1,h2,h3,h4,h5,h6,
      .quiz_title,.quiz_heading,.quiz_question{
        font-family:"Syne",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      #quiz_form{
        color:var(--brand-ink);
      }
      .quiz_step{
        background:transparent;
        border:none;
        box-shadow:none;
      }
      .quiz_step.active{
        box-shadow:none;
      }
      .quiz_box, .quiz-box, .quiz_card, .quiz-card, .quiz_panel, .quiz-panel,
      .quiz_container, .quiz-container, .quiz_wrapper, .quiz-wrapper,
      .quiz_inner, .quiz-inner, .quiz_card-inner, .quiz-card-inner,
      .quiz_box-inner, .quiz-box-inner{
        background:transparent !important;
        background-image:none !important;
        border:none !important;
        box-shadow:none !important;
      }
      .quiz_step .quiz_question,
      .quiz_step h2,
      .quiz_step h3{
        color:var(--brand-ink);
      }
      input, select, textarea, button{
        font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      input, select, textarea{
        background:var(--brand-overlay-light);
        color:var(--brand-ink);
        border:1px solid var(--brand-outline);
      }
      input[type="radio"], input[type="checkbox"]{
        accent-color: rgb(var(--brand-accent));
      }
      input:focus, select:focus, textarea:focus{
        border-color:rgba(var(--brand-accent),0.6);
        box-shadow:0 0 0 3px rgba(var(--brand-accent),0.25);
      }
      button, .next-btn, .prev-btn, .start-btn, .submit-btn, [data-submit="true"]{
        background:linear-gradient(135deg, rgba(var(--brand-accent),0.45), rgba(var(--brand-accent),0.15));
        border:1px solid rgba(var(--brand-accent),0.45);
        color:var(--brand-ink);
      }
      button:hover, .next-btn:hover, .prev-btn:hover, .start-btn:hover, .submit-btn:hover, [data-submit="true"]:hover{
        filter:brightness(1.05);
      }
      #quiz_progress-bar{
        background:linear-gradient(90deg, rgba(var(--brand-accent),0.55), rgba(var(--brand-accent),0.25));
      }
    `;
    document.head.appendChild(style);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", injectBranding);
  } else {
    injectBranding();
  }

  /* ===================== HELPERS ===================== */
  const log = (...a) => DEBUG && console.log("[quiz]", ...a);

  const withTimeout = async (p, ms=12000) => {
    let t; const to = new Promise((_, rej)=> t=setTimeout(()=>rej(new Error("timeout")), ms));
    try { return await Promise.race([p, to]); } finally { clearTimeout(t); }
  };

  const callFn = (url, body) =>
    fetch(url, {
      method: "POST",
      mode: "cors",
      credentials: "omit",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(body)
    });

  const toB64 = (obj) => btoa(encodeURIComponent(JSON.stringify(obj)));

  function labelTextFor(el, root) {
    if (!el) return "";
    if (el.labels && el.labels.length) {
      return String(el.labels[0].textContent || "").trim();
    }
    const parentLabel = el.closest("label");
    if (parentLabel) return String(parentLabel.textContent || "").trim();
    const id = el.id;
    if (id && root) {
      try {
        const lbl = root.querySelector(`label[for="${CSS.escape(id)}"]`);
        if (lbl) return String(lbl.textContent || "").trim();
      } catch (_) {}
    }
    const aria = el.getAttribute("aria-label");
    if (aria) return String(aria).trim();
    const dataName = el.getAttribute("data-name") || el.getAttribute("data-value");
    if (dataName) return String(dataName).trim();

    const wrap = el.closest(
      ".w-radio, .w-checkbox, .quiz_option, .quiz-option, .quiz_answer, .quiz-answer, .option, .answer"
    );
    if (wrap) {
      const preferred = wrap.querySelector(
        ".w-form-label, .option-text, .quiz_option-text, .quiz-option-text, .answer-text, span, p"
      );
      if (preferred) {
        const t = String(preferred.textContent || "").trim();
        if (t) return t;
      }
      const t = String(wrap.textContent || "").trim();
      if (t) return t;
    }
    return "";
  }

  function collectPrettyAnswers(root) {
    const out = [];
    const steps = Array.from(root.querySelectorAll(".quiz_step"));
    for (const step of steps) {
      if (step && step.offsetParent === null && getComputedStyle(step).display === "none") {
        continue;
      }
      const qEl =
        step.querySelector(".quiz_question") ||
        step.querySelector(".quiz_heading") ||
        step.querySelector("h2") ||
        step.querySelector("h3") ||
        step.querySelector("legend");

      let question = String(qEl?.textContent || "").trim();
      if (!question) {
        question =
          step.getAttribute("data-question") ||
          step.getAttribute("data-title") ||
          step.getAttribute("data-step-title") ||
          step.id ||
          "";
      }
      if (!question) continue;

      const values = [];
      const inputs = Array.from(step.querySelectorAll("input, select, textarea"));

      for (const el of inputs) {
        if (el.disabled) continue;
        const type = (el.type || "").toLowerCase();

        if (type === "radio" || type === "checkbox") {
          if (!el.checked) continue;
          let val = el.value;
          if (!val || val === "on") val = labelTextFor(el, root);
          if (!val) val = el.name || el.id || "Selected";
          values.push(String(val).trim());
          continue;
        }

        if (el.tagName === "SELECT") {
          const opt = el.options?.[el.selectedIndex];
          const val = opt?.textContent || el.value;
          if (val) values.push(String(val).trim());
          continue;
        }

        if (type === "submit" || type === "button") continue;
        if (el.value) values.push(String(el.value).trim());
      }

      if (values.length) {
        out.push({ question, answer: values.join(", ") });
      }
    }
    return out;
  }

  const LOCAL_CAR_CATALOG = [
    { brand: "Toyota", model: "Corolla", type: "sedan", fuel: "gas", budget: "low", origin: "japan", tags: ["city", "reliable"] },
    { brand: "Honda", model: "Civic", type: "sedan", fuel: "gas", budget: "low", origin: "japan", tags: ["city", "reliable"] },
    { brand: "Hyundai", model: "Elantra", type: "sedan", fuel: "gas", budget: "low", origin: "korea", tags: ["city", "budget"] },
    { brand: "Volkswagen", model: "Golf", type: "hatch", fuel: "gas", budget: "mid", origin: "germany", tags: ["city", "compact"] },
    { brand: "Mazda", model: "CX-5", type: "suv", fuel: "gas", budget: "mid", origin: "japan", tags: ["family"] },
    { brand: "Toyota", model: "RAV4 Hybrid", type: "suv", fuel: "hybrid", budget: "mid", origin: "japan", tags: ["family"] },
    { brand: "Nissan", model: "Leaf", type: "hatch", fuel: "electric", budget: "low", origin: "japan", tags: ["city", "ev"] },
    { brand: "Tesla", model: "Model 3", type: "sedan", fuel: "electric", budget: "mid", origin: "usa", tags: ["tech", "ev"] },
    { brand: "Tesla", model: "Model Y", type: "suv", fuel: "electric", budget: "high", origin: "usa", tags: ["family", "ev"] },
    { brand: "BYD", model: "Atto 3", type: "suv", fuel: "electric", budget: "mid", origin: "china", tags: ["family", "ev"] },
    { brand: "Geely", model: "Coolray", type: "suv", fuel: "gas", budget: "mid", origin: "china", tags: ["city"] },
    { brand: "Chery", model: "Tiggo 7", type: "suv", fuel: "gas", budget: "mid", origin: "china", tags: ["family"] },
    { brand: "MG", model: "4", type: "hatch", fuel: "electric", budget: "mid", origin: "china", tags: ["city", "ev"] },
    { brand: "BMW", model: "3 Series", type: "sedan", fuel: "gas", budget: "high", origin: "germany", tags: ["sport", "luxury"] },
    { brand: "Mercedes-Benz", model: "C-Class", type: "sedan", fuel: "gas", budget: "high", origin: "germany", tags: ["luxury", "comfort"] },
    { brand: "Audi", model: "A4", type: "sedan", fuel: "gas", budget: "high", origin: "germany", tags: ["luxury", "tech"] },
    { brand: "Lexus", model: "RX", type: "suv", fuel: "hybrid", budget: "high", origin: "japan", tags: ["luxury", "family"] },
    { brand: "Volvo", model: "XC60", type: "suv", fuel: "hybrid", budget: "high", origin: "sweden", tags: ["safe", "family"] }
  ];

  const imageProxyFor = (brand, model) => {
    const qs = new URLSearchParams({
      brand: String(brand || ""),
      model: String(model || "")
    });
    return `${NETLIFY_BASE}/carImageProxy?${qs.toString()}`;
  };

  function normalizeAnswersText(answers) {
    if (Array.isArray(answers)) {
      return answers.map((a) => `${a?.question || ""} ${a?.answer || ""}`).join(" ").toLowerCase();
    }
    return JSON.stringify(answers || {}).toLowerCase();
  }

  function detectMonthlyBudget(text) {
    const matches = [...text.matchAll(/(\d{2,4})[^\\n]{0,10}month/g)];
    if (!matches.length) return null;
    const nums = matches
      .map((m) => parseInt(m[1], 10))
      .filter((n) => Number.isFinite(n));
    if (!nums.length) return null;
    return Math.round(nums.reduce((a, b) => a + b, 0) / nums.length);
  }

  function detectBudgetTier(text) {
    const monthly = detectMonthlyBudget(text);
    if (monthly !== null) {
      if (monthly <= 600) return "low";
      if (monthly <= 1000) return "mid";
      return "high";
    }
    if (/(cheap|budget|low|affordable|economy)/.test(text)) return "low";
    if (/(luxury|premium|performance|expensive)/.test(text)) return "high";
    return "mid";
  }

  function localMatchPicks(answers) {
    const text = normalizeAnswersText(answers);
    const wants = {
      electric: /(electric|ev|battery)/.test(text),
      hybrid: /(hybrid)/.test(text),
      gas: /(gas|petrol)/.test(text),
      suv: /(suv|crossover|family|kids|space|spacious)/.test(text),
      truck: /(truck|pickup|towing)/.test(text),
      hatch: /(hatch|compact|city)/.test(text),
      sedan: /(sedan|saloon|comfort|quiet|luxury)/.test(text),
      sport: /(sport|performance|fast)/.test(text),
      city: /(city|suburb|urban|commute)/.test(text),
      china: /(china|chinese)/.test(text),
      japan: /(japan|japanese)/.test(text),
      korea: /(korea|korean)/.test(text),
      germany: /(german|germany)/.test(text)
    };

    const budgetTier = detectBudgetTier(text);

    function scoreCar(car) {
      let score = 0;
      if (wants.electric && car.fuel === "electric") score += 4;
      if (wants.hybrid && car.fuel === "hybrid") score += 3;
      if (wants.gas && car.fuel === "gas") score += 2;
      if (wants.suv && car.type === "suv") score += 3;
      if (wants.truck && car.type === "truck") score += 3;
      if (wants.hatch && car.type === "hatch") score += 2;
      if (wants.sedan && car.type === "sedan") score += 2;
      if (wants.sport && car.tags?.includes("sport")) score += 2;
      if (wants.city && car.tags?.includes("city")) score += 1;
      if (budgetTier && car.budget === budgetTier) score += 2;
      if (wants.china && car.origin === "china") score += 4;
      if (wants.japan && car.origin === "japan") score += 3;
      if (wants.korea && car.origin === "korea") score += 3;
      if (wants.germany && car.origin === "germany") score += 3;
      return score;
    }

    const filterIfEnough = (list, predicate) => {
      const filtered = list.filter(predicate);
      return filtered.length >= 3 ? filtered : list;
    };

    const originFilters = [];
    if (wants.china) originFilters.push("china");
    if (wants.japan) originFilters.push("japan");
    if (wants.korea) originFilters.push("korea");
    if (wants.germany) originFilters.push("germany");

    const fuelFilters = [];
    if (wants.electric) fuelFilters.push("electric");
    if (wants.hybrid) fuelFilters.push("hybrid");
    if (wants.gas) fuelFilters.push("gas");

    const typeFilters = [];
    if (wants.suv) typeFilters.push("suv");
    if (wants.hatch) typeFilters.push("hatch");
    if (wants.sedan) typeFilters.push("sedan");
    if (wants.truck) typeFilters.push("truck");

    let candidates = LOCAL_CAR_CATALOG.slice();
    if (originFilters.length) {
      candidates = filterIfEnough(candidates, (c) => originFilters.includes(c.origin));
    }
    if (fuelFilters.length) {
      candidates = filterIfEnough(candidates, (c) => fuelFilters.includes(c.fuel));
    }
    if (typeFilters.length) {
      candidates = filterIfEnough(candidates, (c) => typeFilters.includes(c.type));
    }

    const ranked = candidates
      .map((car) => ({ car, score: scoreCar(car) }))
      .sort((a, b) => b.score - a.score);

    const picks = [];
    const used = new Set();
    for (const item of ranked) {
      if (picks.length >= 3) break;
      const key = `${item.car.brand}:${item.car.model}`;
      if (used.has(key)) continue;
      picks.push(item.car);
      used.add(key);
    }

    while (picks.length < 3) {
      picks.push(LOCAL_CAR_CATALOG[picks.length % LOCAL_CAR_CATALOG.length]);
    }

    return picks.slice(0, 3).map((car) => ({
      brand: car.brand,
      model: car.model,
      reason: car.type === "suv"
        ? "Good space and comfort for daily driving and passengers."
        : car.fuel === "electric"
          ? "Efficient electric option that fits your usage."
          : "Balanced daily driver that fits your preferences.",
      image: imageProxyFor(car.brand, car.model)
    }));
  }

  function normalizeKey(brand, model) {
    return `${brand || ""}${model || ""}`.toLowerCase().replace(/[^a-z0-9]/g, "");
  }

  function isStaticFallback(picks) {
    if (!Array.isArray(picks) || picks.length !== 3) return false;
    const keys = picks.map((p) => normalizeKey(p.brand, p.model));
    const expected = ["mercedesbenzcclass", "bmw3series", "audia4"];
    return expected.every((k) => keys.includes(k));
  }

  function localFallbackPicks(answers) {
    return localMatchPicks(answers);
  }

  function collectAnswers(root) {
    const out = {};
    const fields = root.querySelectorAll('input, select, textarea');
    for (const el of fields) {
      if (el.disabled || !el.name) continue;
      const name = el.name.trim();
      const type = (el.type || '').toLowerCase();
      if (type === 'radio')   { if (el.checked) out[name] = el.value; continue; }
      if (type === 'checkbox'){ if (el.checked) (out[name] ??= []).push(el.value); continue; }
      out[name] = el.value;
    }
    out._meta = { submittedAt: new Date().toISOString(), ua: navigator.userAgent };
    return out;
  }

  function wireFakeSubmit(form) {
    const fake = document.querySelector('.submit-btn, [data-submit="true"]');
    if (!fake) return;
    fake.addEventListener('click', (e) => {
      if (fake.type !== 'submit') {
        e.preventDefault();
        if (typeof form.requestSubmit === 'function') {
          form.requestSubmit();
        } else {
          form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
        }
      }
    });
  }

  /* --- tiny custom validation so user didn't skip everything --- */
  function validateVisibleSteps(formRoot) {
    // rule: every *visible* .quiz_step must have at least one checked radio,
    // unless that step has any [data-optional] flag
    const steps = Array.from(formRoot.querySelectorAll('.quiz_step'))
      .filter(step => step && document.body.contains(step));

    for (const step of steps) {
      if (step.hasAttribute('data-optional')) continue;

      const radios = Array.from(step.querySelectorAll('input[type="radio"][name]'));
      if (!radios.length) continue;

      const oneChecked = radios.some(r => r.checked);
      if (!oneChecked) {
        step.scrollIntoView({behavior:"smooth",block:"center"});
        alert("Please answer this question before continuing.");
        return false;
      }
    }

    return true;
  }

  /* ===================== STEPPER ===================== */
  document.addEventListener('DOMContentLoaded', () => {
    injectBranding();
    const formRoot = document.getElementById('quiz_form');
    if (!formRoot) { console.error('[quiz] #quiz_form not found'); return; }

    // kill native validation
    formRoot.setAttribute('novalidate', 'novalidate');
    formRoot.querySelectorAll('[required]').forEach(el => el.removeAttribute('required'));

    const initialSteps   = Array.from(formRoot.querySelectorAll('.quiz_step'));
    const originalOrder  = initialSteps.map(s => s.id);
    const originalHTML   = new Map(initialSteps.map(s => [s.id, s.outerHTML]));
    const removedSet     = new Set();
    const questionRemovedMap = new Map();

    const esc = (id) =>
      (window.CSS && CSS.escape)
        ? CSS.escape(id)
        : String(id).replace(/([ !"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~])/g,'\\$1');

    const currentSteps = () => Array.from(formRoot.querySelectorAll('.quiz_step'));

    // ðŸ”§ FIXED VERSION
    function restoreStep(id) {
      if (!originalHTML.has(id) || !removedSet.has(id)) return;

      // recreate the step DOM
      const temp = document.createElement('div');
      temp.innerHTML = (originalHTML.get(id) || "").trim();
      const clone = temp.firstElementChild;

      // OLD BEHAVIOR (BROKE IN SOME CASES):
      // we tried to insertBefore(...) using the "next" original neighbor,
      // but that neighbor isn't always a DIRECT child of formRoot.
      // That caused the NotFoundError.
      //
      // NEW BEHAVIOR:
      // just append at the end of the form. Safe. No NotFoundError.
      formRoot.appendChild(clone);

      attachListenersToStep(clone);
      removedSet.delete(id);
    }

    function removeStep(id) {
      const el = formRoot.querySelector('#' + esc(id));
      if (el && el.parentNode) el.parentNode.removeChild(el);
      removedSet.add(id);
    }

    function getNextIndex(i){
      const s=currentSteps();
      let n=i+1;
      while(n<s.length && removedSet.has(s[n].id)) n++;
      return n;
    }

    function getPrevIndex(i){
      const s=currentSteps();
      let p=i-1;
      while(p>=0 && removedSet.has(s[p].id)) p--;
      return p;
    }

    function showStep(index){
      const s=currentSteps();
      if(index<0||index>=s.length) return;
      s.forEach((el,i)=>{
        el.classList.remove('active','prev');
        if(i===index) el.classList.add('active');
        else if(i<index) el.classList.add('prev');
      });
      (formRoot.scrollIntoView?.({behavior:'smooth',block:'start'}))
        || window.scrollTo({top:Math.max(0, formRoot.offsetTop-20),behavior:'smooth'});
    }

    function applyRemovalsForStep(stepId, removeList) {
      // restore anything we removed LAST time because of this question
      if (questionRemovedMap.has(stepId)) {
        questionRemovedMap.get(stepId).forEach(id => {
          if (removedSet.has(id)) restoreStep(id);
        });
        questionRemovedMap.delete(stepId);
      }

      const toRemove = (Array.isArray(removeList) ? removeList : String(removeList||'').split(','))
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);

      const actuallyRemoved = [];
      toRemove.forEach(id => {
        if (id === stepId) return;
        const target = formRoot.querySelector('#' + esc(id));
        if (target) {
          removeStep(id);
          actuallyRemoved.push(id);
        }
      });

      if (actuallyRemoved.length) {
        questionRemovedMap.set(stepId, actuallyRemoved);
      }

      const s=currentSteps();
      const idx=s.findIndex(x=>x.id===stepId);
      const next=getNextIndex(idx);
      if (next < s.length) setTimeout(()=>showStep(next), 20);
    }

    function attachListenersToStep(stepEl){
      if (!stepEl) return;
      const stepId = stepEl.id;

      // radios -> auto-advance
      stepEl.querySelectorAll('input[type="radio"]').forEach(radio=>{
        radio.removeEventListener('change', radio._quizListener);
        const onChange = e => {
          if (!AUTO_NEXT_SKIP.has(stepId)) {
            const dr = (e.target?.dataset?.remove || "");
            if (dr) applyRemovalsForStep(stepId, dr);
            else handleRadioChangeFallback(e, stepId);
          }
        };
        radio._quizListener = onChange;
        radio.addEventListener('change', onChange);

        radio.removeEventListener('click', radio._quizClickFix);
        const clickFix = () => {
          if(radio.checked && !AUTO_NEXT_SKIP.has(stepId)) {
            const dr = (radio.dataset?.remove || "");
            if (dr) applyRemovalsForStep(stepId, dr);
            else handleRadioChangeFallback({target:radio}, stepId);
          }
        };
        radio._quizClickFix = clickFix;
        radio.addEventListener('click', clickFix);
      });

      // budget special logic (q2)
      if (stepId === 'q2') {
        const icons = stepEl.querySelectorAll('.quiz_option-icon[data-remove], #Total-budget, #Monthly-budget');
        icons.forEach(el=>{
          el.removeEventListener('click', el._q2Click);
          el._q2Click = ()=>{
            icons.forEach(x => {
              x.setAttribute('aria-pressed','false');
              x.classList.remove('is-active');
            });
            el.setAttribute('aria-pressed','true');
            el.classList.add('is-active');

            let removeTargets = (el.getAttribute('data-remove') || "").trim().toLowerCase();
            if (!removeTargets && el.id === 'Total-budget')   removeTargets = 'q3';
            if (!removeTargets && el.id === 'Monthly-budget') removeTargets = 'q4';

            if (removeTargets) applyRemovalsForStep('q2', removeTargets);
          };
          el.addEventListener('click', el._q2Click, true);
        });
      }

      // checkboxes (no auto-next)
      stepEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
        cb.removeEventListener('change', cb._quizListener);
        const noop=()=>{};
        cb._quizListener=noop;
        cb.addEventListener('change', noop);
      });

      // prev / next buttons
      const prevBtn = stepEl.querySelector('.prev-btn');
      if (prevBtn){
        prevBtn.removeEventListener('click', prevBtn._quizPrevListener);
        const l = ev=>{
          ev.preventDefault();
          const s=currentSteps();
          const idx=s.findIndex(x=>x===stepEl);
          const p=getPrevIndex(idx);
          if(p>=0) showStep(p);
        };
        prevBtn._quizPrevListener = l;
        prevBtn.addEventListener('click', l);
      }

      const nextBtn = stepEl.querySelector('.next-btn');
      if (nextBtn){
        nextBtn.removeEventListener('click', nextBtn._quizNextListener);
        const l = ev=>{
          ev.preventDefault();
          const s=currentSteps();
          const idx=s.findIndex(x=>x===stepEl);
          const n=getNextIndex(idx);
          if(n<s.length) showStep(n);
        };
        nextBtn._quizNextListener = l;
        nextBtn.addEventListener('click', l);
      }

      const startBtn = stepEl.querySelector('.start-btn');
      if (startBtn){
        startBtn.removeEventListener('click', startBtn._quizStartListener);
        const l = ev=>{
          ev.preventDefault();
          const s=currentSteps();
          const idx=s.findIndex(x=>x===stepEl);
          const n=getNextIndex(idx);
          if(n<s.length) showStep(n);
        };
        startBtn._quizStartListener = l;
        startBtn.addEventListener('click', l);
      }
    }

    function handleRadioChangeFallback(e, stepId){
      const s=currentSteps();
      const idx=s.findIndex(x=>x.id===stepId);
      const next=getNextIndex(idx);
      if (next < s.length) setTimeout(()=>showStep(next), 20);
    }

    // attach listeners on load
    initialSteps.forEach(attachListenersToStep);
    showStep(0);
  });

  /* ===================== PROGRESS BAR ===================== */
  document.addEventListener("DOMContentLoaded", function(){
    const steps=["q1","q2","q3","q4","q5","q6","q7","q8","q9","q10"];
    const bar=document.getElementById("quiz_progress-bar");
    const obs=new MutationObserver(()=>{
      const active=document.querySelector(".quiz_step.active");
      if (active && steps.includes(active.id)) {
        const visible=steps.filter(id=>document.getElementById(id));
        const idx=visible.indexOf(active.id)+1;
        const pct=(idx/visible.length)*100;
        if (bar) bar.style.width=pct+"%";
      }
    });
    const form=document.getElementById("quiz_form");
    if (form) obs.observe(form,{attributes:true,childList:true,subtree:true});
  });

  /* ===================== SUBMIT â†’ AI â†’ SAVE GUEST â†’ REDIRECT ===================== */
  document.addEventListener("DOMContentLoaded", ()=>{
    const form = document.getElementById("quiz_form") || document.querySelector("form");
    if(!form) return;

    form.setAttribute('novalidate','novalidate');
    form.querySelectorAll('[required]').forEach(el => el.removeAttribute('required'));

    wireFakeSubmit(form);

    form.addEventListener("submit", async (e)=>{
      e.preventDefault();

      const formRoot = document.getElementById('quiz_form');
      if (!validateVisibleSteps(formRoot)) {
        return;
      }

      const submitBtn = form.querySelector('button[type="submit"], input[type="submit"], .submit-btn, [data-submit="true"]');
      const originalText = submitBtn ? (submitBtn.innerText || submitBtn.value) : null;

      try{
        if (submitBtn){
          if (submitBtn.innerText !== undefined) submitBtn.innerText = "Finding your carsâ€¦";
          if (submitBtn.value !== undefined)     submitBtn.value     = "Finding your carsâ€¦";
          submitBtn.disabled = true;
        }

        const answers = collectAnswers(form);
        const prettyAnswers = collectPrettyAnswers(form);
        const payloadAnswers = (prettyAnswers && prettyAnswers.length) ? prettyAnswers : answers;
        log("answers", answers);
        log("pretty", prettyAnswers);

        let text = null;
        let picks = null;

        // 1. try live
        try {
          const res = await withTimeout(callFn(FN_URL, { answers: payloadAnswers }), 12000);
          if (!res.ok) {
            const errTxt = await res.text().catch(()=>"(no body)");
            console.warn("[quiz] carMatch non-OK:", res.status, errTxt);
            throw new Error("non-200");
          }
          text = await res.text();
        } catch (err) {
          console.warn("[quiz] carMatch failed, trying mock=1â€¦", err?.message || err);
          // 2. fallback mock
          const mockURL = FN_URL + (FN_URL.includes('?') ? '&' : '?') + 'mock=1';
          try {
          const mock = await withTimeout(callFn(mockURL, { answers: payloadAnswers }), 6000);
            if (!mock.ok) {
              const mTxt = await mock.text().catch(()=>"(no body)");
              console.warn("[quiz] mock non-OK:", mock.status, mTxt);
              throw new Error("mock non-200");
            }
            text = await mock.text();
          } catch (e2) {
            console.warn("[quiz] mock failed, using local fallback.", e2?.message || e2);
            picks = localFallbackPicks(payloadAnswers);
          }
        }

        if (!picks) {
          try { picks = JSON.parse(text); }
          catch {
            const m = text && text.match(/\[[\s\S]*\]$/);
            if (m) { try { picks = JSON.parse(m[0]); } catch(_){} }
          }
        }

        if (!Array.isArray(picks) || picks.length === 0) {
          console.warn("[quiz] parse error. Raw:", text);
          alert("We couldnâ€™t parse the recommendations. Please try again.");
          return;
        }

        if (isStaticFallback(picks)) {
          const local = localMatchPicks(payloadAnswers);
          if (Array.isArray(local) && local.length) picks = local;
        }

        // stash locally for results + signup modal
        sessionStorage.setItem("carPicks", JSON.stringify(picks));
        sessionStorage.setItem("carAnswers", JSON.stringify(payloadAnswers));
        sessionStorage.setItem("carAnswersRaw", JSON.stringify(answers));

        // save anonymous guest result (non-blocking)
        try {
          await fetch(`${NETLIFY_BASE}/resultsSavePublicCORS`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              answers: payloadAnswers,
              top3: picks
            })
          });
        } catch (saveErr) {
          console.warn("[quiz] guest save failed (non-blocking)", saveErr);
        }

        const picksB64 = toB64(picks);
        window.location.assign(`${RESULTS_URL}?picks=${encodeURIComponent(picksB64)}`);

      } finally {
        if (submitBtn){
          if (submitBtn.innerText !== undefined) submitBtn.innerText = originalText;
          if (submitBtn.value !== undefined)     submitBtn.value     = originalText;
          submitBtn.disabled = false;
        }
      }
    }, { capture:true });
  });
})();
</script>
